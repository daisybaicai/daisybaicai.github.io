(window.webpackJsonp=window.webpackJsonp||[]).push([[28],{239:function(t,e,a){"use strict";a.r(e);var r=a(0),n=Object(r.a)({},(function(){var t=this,e=t.$createElement,a=t._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"diff"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#diff"}},[t._v("#")]),t._v(" diff")]),t._v(" "),a("h2",{attrs:{id:"传统-diff-算法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#传统-diff-算法"}},[t._v("#")]),t._v(" 传统 diff 算法")]),t._v(" "),a("p",[t._v("计算一棵树形结构转换成另一棵树形结构的最少操作，是一个复杂且值得研究的问题。传统 diff 算法通过循环递归对节点进行依次对比，效率低下，算法复杂度达到 O(n^3)，其中 n 是树中节点的总数。")]),t._v(" "),a("h2",{attrs:{id:"详解-react-diff"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#详解-react-diff"}},[t._v("#")]),t._v(" 详解 React diff")]),t._v(" "),a("p",[t._v("React 通过制定大胆的策略，将 O(n^3) 复杂度的问题转换成 O(n) 复杂度的问题。")]),t._v(" "),a("h3",{attrs:{id:"diff-策略"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#diff-策略"}},[t._v("#")]),t._v(" diff 策略")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("Web UI 中 DOM 节点跨层级的移动操作特别少，可以忽略不计。")])]),t._v(" "),a("li",[a("p",[t._v("拥有相同类的两个组件将会生成相似的树形结构，拥有不同类的两个组件将会生成不同的树形结构。")])]),t._v(" "),a("li",[a("p",[t._v("对于同一层级的一组子节点，它们可以通过唯一 id 进行区分。")])]),t._v(" "),a("li",[a("p",[t._v("基于以上三个前提策略，React 分别对 tree diff、component diff 以及 element diff 进行算法优化，事实也证明这三个前提策略是合理且准确的，它保证了整体界面构建的性能。")])])]),t._v(" "),a("p",[t._v("tree diff")]),t._v(" "),a("p",[t._v("component diff")]),t._v(" "),a("p",[t._v("element diff")]),t._v(" "),a("p",[t._v("---qita\n15 diff算法?\n把树形结构按照层级分解，只比较同级元素。\n给列表结构的每个单元添加唯一的key属性，方便比较。\nReact 只会匹配相同 class 的 component（这里面的class指的是组件的名字）\n合并操作，调用 component 的 setState 方法的时候, React 将其标记为 - dirty.到每一个事件循环结束, React 检查所有标记 dirty的 component重新绘制.\n选择性子树渲染。开发人员可以重写shouldComponentUpdate提高diff的性能")]),t._v(" "),a("p",[t._v("19 react 的虚拟dom是怎么实现的\n首先说说为什么要使用Virturl DOM，因为操作真实DOM的耗费的性能代价太高，所以react内部使用js实现了一套dom结构，在每次操作在和真实dom之前，使用实现好的diff算法，对虚拟dom进行比较，递归找出有变化的dom节点，然后对其进行更新操作。为了实现虚拟DOM，我们需要把每一种节点类型抽象成对象，每一种节点类型有自己的属性，也就是prop，每次进行diff的时候，react会先比较该节点类型，假如节点类型不一样，那么react会直接删除该节点，然后直接创建新的节点插入到其中，假如节点类型一样，那么会比较prop是否有更新，假如有prop不一样，那么react会判定该节点有更新，那么重渲染该节点，然后在对其子节点进行比较，一层一层往下，直到没有子节点")]),t._v(" "),a("p",[t._v("#20 react 的渲染过程中，兄弟节点之间是怎么处理的？也就是key值不一样的时候\n通常我们输出节点的时候都是map一个数组然后返回一个ReactNode，为了方便react内部进行优化，我们必须给每一个reactNode添加key，这个key prop在设计值处不是给开发者用的，而是给react用的，大概的作用就是给每一个reactNode添加一个身份标识，方便react进行识别，在重渲染过程中，如果key一样，若组件属性有所变化，则react只更新组件对应的属性；没有变化则不更新，如果key不一样，则react先销毁该组件，然后重新创建该组件\n"),a("strong",[t._v("参考：")])]),t._v(" "),a("ul",[a("li",[a("a",{attrs:{href:"https://zhuanlan.zhihu.com/p/20346379",target:"_blank",rel:"noopener noreferrer"}},[t._v("https://zhuanlan.zhihu.com/p/20346379"),a("OutboundLink")],1)])])])}),[],!1,null,null,null);e.default=n.exports}}]);