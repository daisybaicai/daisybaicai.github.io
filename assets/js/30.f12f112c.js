(window.webpackJsonp=window.webpackJsonp||[]).push([[30],{237:function(t,e,a){"use strict";a.r(e);var s=a(0),o=Object(s.a)({},(function(){var t=this,e=t.$createElement,a=t._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"react-hooks-基础概念"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#react-hooks-基础概念"}},[t._v("#")]),t._v(" React Hooks(基础概念)")]),t._v(" "),a("h2",{attrs:{id:"hook简介"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#hook简介"}},[t._v("#")]),t._v(" Hook简介")]),t._v(" "),a("h3",{attrs:{id:"好处"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#好处"}},[t._v("#")]),t._v(" 好处")]),t._v(" "),a("p",[t._v("简单来说：在非class的情况下可以使用更多的react特性，以及更好地解决了组件逻辑复用等问题。")]),t._v(" "),a("h4",{attrs:{id:"解决了以下问题"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#解决了以下问题"}},[t._v("#")]),t._v(" 解决了以下问题")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("组件复用状态逻辑很难")])]),t._v(" "),a("li",[a("p",[t._v("复杂组件难以理解")]),t._v(" "),a("ul",[a("li",[t._v("大多数时候，我们使用class来编写时，不能将组件拆分成更小的颗粒，因为逻辑无处不在")]),t._v(" "),a("li",[a("strong",[t._v("Hook 将组件中相互关联的部分拆分成更小的函数（比如设置订阅或请求数据）")]),t._v("，而并非强制按照生命周期划分。你还可以使用 reducer 来管理组件的内部状态，使其更加可预测。")])])]),t._v(" "),a("li",[a("p",[t._v("class")]),t._v(" "),a("ul",[a("li",[t._v("class中this的绑定，以及一些经验开发者对于class组件与函数组件的分歧")])])])]),t._v(" "),a("h2",{attrs:{id:"hook概念"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#hook概念"}},[t._v("#")]),t._v(" Hook概念")]),t._v(" "),a("p",[t._v("Hook 是一些可以让你在函数组件里“钩入” React state 及生命周期等特性的函数。Hook 不能在 class 组件中使用 —— 这使得你不使用 class 也能使用 React。")]),t._v(" "),a("h3",{attrs:{id:"state-hook"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#state-hook"}},[t._v("#")]),t._v(" State Hook")]),t._v(" "),a("p",[a("code",[t._v("useState")]),t._v(" 会返回一对值："),a("strong",[t._v("当前")]),t._v("状态和一个让你更新它的函数，你可以在事件处理函数中或其他一些地方调用这个函数。它类似 class 组件的 "),a("code",[t._v("this.setState")]),t._v("，但是它不会把新的 state 和旧的 state 进行合并。")]),t._v(" "),a("div",{staticClass:"language-react extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("import React, { useState } from 'react';\n\nfunction Example() {\n  // 声明一个叫 “count” 的 state 变量。\n  const [count, setCount] = useState(0);\n\n  return (\n    <div>\n      <p>You clicked {count} times</p>\n      <button onClick={() => setCount(count + 1)}>\n        Click me\n      </button>\n    </div>\n  );\n}\n")])])]),a("h3",{attrs:{id:"effect-hook"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#effect-hook"}},[t._v("#")]),t._v(" Effect Hook")]),t._v(" "),a("h4",{attrs:{id:"副作用："}},[a("a",{staticClass:"header-anchor",attrs:{href:"#副作用："}},[t._v("#")]),t._v(" 副作用：")]),t._v(" "),a("p",[t._v("你之前可能已经在 React 组件中执行过数据获取、订阅或者手动修改过 DOM。我们统一把这些操作称为“副作用”，或者简称为“作用”。")]),t._v(" "),a("h4",{attrs:{id:"类比class组件"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#类比class组件"}},[t._v("#")]),t._v(" 类比class组件")]),t._v(" "),a("p",[a("code",[t._v("useEffect")]),t._v(" 就是一个 Effect Hook，给函数组件增加了操作副作用的能力。它跟 class 组件中的 "),a("code",[t._v("componentDidMount")]),t._v("、"),a("code",[t._v("componentDidUpdate")]),t._v(" 和 "),a("code",[t._v("componentWillUnmount")]),t._v(" 具有相同的用途，只不过被合并成了一个 API。")]),t._v(" "),a("h3",{attrs:{id:"hook使用规则"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#hook使用规则"}},[t._v("#")]),t._v(" Hook使用规则")]),t._v(" "),a("ul",[a("li",[t._v("只能在最外层调用Hook")]),t._v(" "),a("li",[t._v("只能在React函数组件中调用")])]),t._v(" "),a("h3",{attrs:{id:"自定义hook"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#自定义hook"}},[t._v("#")]),t._v(" 自定义Hook")]),t._v(" "),a("p",[t._v("有时候我们会想要在组件之间重用一些状态逻辑。目前为止，有两种主流方案来解决这个问题："),a("a",{attrs:{href:"https://zh-hans.reactjs.org/docs/higher-order-components.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("高阶组件"),a("OutboundLink")],1),t._v("和 "),a("a",{attrs:{href:"https://zh-hans.reactjs.org/docs/render-props.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("render props"),a("OutboundLink")],1),t._v("。自定义 Hook 可以让你在不增加组件的情况下达到同样的目的。")]),t._v(" "),a("p",[t._v("将需要重用的逻辑状态，抽象在一个自定义Hooks中，其他需要用到该逻辑的只需要调用即可，同时另外调用的组件的state是完全独立的。")]),t._v(" "),a("p",[t._v("Hook 是一种复用"),a("em",[t._v("状态逻辑")]),t._v("的方式，它不复用 state 本身。事实上 Hook 的每次"),a("em",[t._v("调用")]),t._v("都有一个完全独立的 state —— 因此你可以在单个组件中多次调用同一个自定义 Hook。")]),t._v(" "),a("p",[t._v("自定义 Hook 更像是一种约定而不是功能。如果函数的名字以 “"),a("code",[t._v("use")]),t._v("” 开头并调用其他 Hook，我们就说这是一个自定义 Hook。 "),a("code",[t._v("useSomething")]),t._v(" 的命名约定可以让我们的 linter 插件在使用 Hook 的代码中找到 bug。")]),t._v(" "),a("h3",{attrs:{id:"其他hook"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#其他hook"}},[t._v("#")]),t._v(" 其他Hook")]),t._v(" "),a("p",[t._v("useContent：让你不使用组件嵌套就可以订阅 React 的 Context")]),t._v(" "),a("div",{staticClass:"language-react extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("function Example() {\n  const locale = useContext(LocaleContext);\n  const theme = useContext(ThemeContext);\n  // ...\n}\n")])])]),a("p",[t._v("useReducer：让你通过 reducer 来管理组件本地的复杂 state。")]),t._v(" "),a("div",{staticClass:"language-react extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("function Todos() {\n  const [todos, dispatch] = useReducer(todosReducer);\n  // ...\n")])])])])}),[],!1,null,null,null);e.default=o.exports}}]);